import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:whatsapp_clone/core/utils/result.dart';
import 'package:whatsapp_clone/core/errors/failures.dart';
import 'package:whatsapp_clone/features/messaging/domain/entities/message.dart';
import 'package:whatsapp_clone/features/messaging/domain/repositories/i_message_repository.dart';
import 'package:whatsapp_clone/features/messaging/domain/usecases/send_message_usecase.dart';

// Mock repository
class MockMessageRepository extends Mock implements IMessageRepository {}

void main() {
  setUpAll(() {
    // Register fallback values for mocktail
    registerFallbackValue(Message(
      id: 'fallback-id',
      senderId: 'fallback-sender',
      roomId: 'fallback-room',
      content: 'fallback-content',
      timestamp: DateTime.now(),
    ));
  });

  group('SendMessageUseCase', () {
    late SendMessageUseCase useCase;
    late MockMessageRepository mockRepository;

    setUp(() {
      mockRepository = MockMessageRepository();
      useCase = SendMessageUseCase(mockRepository);
    });

    // Test data
    const testSenderId = 'sender-123';
    const testRoomId = 'room-456';
    const testContent = 'Hello, World!';
    final testTimestamp = DateTime(2024, 1, 15, 10, 30);

    final testParams = SendMessageParams(
      senderId: testSenderId,
      roomId: testRoomId,
      content: testContent,
      messageType: MessageType.text,
    );

    final expectedMessage = Message(
      id: 'generated-id', // Will be generated by repository
      senderId: testSenderId,
      roomId: testRoomId,
      content: testContent,
      timestamp: testTimestamp,
      messageType: MessageType.text,
    );

    group('Success Cases', () {
      test('should send text message successfully', () async {
        // Arrange
        when(() => mockRepository.sendMessage(any()))
            .thenAnswer((_) async => Success(expectedMessage));

        // Act
        final result = await useCase.call(testParams);

        // Assert
        expect(result.isSuccess, true);
        expect(result.dataOrNull, expectedMessage);
        
        // Verify repository was called with correct parameters
        verify(() => mockRepository.sendMessage(any())).called(1);
      });

      test('should send image message successfully', () async {
        // Arrange
        final imageParams = testParams.copyWith(messageType: MessageType.image);
        final imageMessage = expectedMessage.copyWith(messageType: MessageType.image);
        
        when(() => mockRepository.sendMessage(any()))
            .thenAnswer((_) async => Success(imageMessage));

        // Act
        final result = await useCase.call(imageParams);

        // Assert
        expect(result.isSuccess, true);
        expect(result.dataOrNull?.messageType, MessageType.image);
      });

      test('should send file message successfully', () async {
        // Arrange
        final fileParams = testParams.copyWith(messageType: MessageType.file);
        final fileMessage = expectedMessage.copyWith(messageType: MessageType.file);
        
        when(() => mockRepository.sendMessage(any()))
            .thenAnswer((_) async => Success(fileMessage));

        // Act
        final result = await useCase.call(fileParams);

        // Assert
        expect(result.isSuccess, true);
        expect(result.dataOrNull?.messageType, MessageType.file);
      });
    });

    group('Failure Cases', () {
      test('should return failure when repository fails', () async {
        // Arrange
        const failure = ServerFailure(message: 'Failed to send message');
        when(() => mockRepository.sendMessage(any()))
            .thenAnswer((_) async => const ResultFailure(failure));

        // Act
        final result = await useCase.call(testParams);

        // Assert
        expect(result.isFailure, true);
        expect(result.failureOrNull, failure);
      });

      test('should return validation failure for empty content', () async {
        // Arrange
        final emptyParams = testParams.copyWith(content: '');

        // Act
        final result = await useCase.call(emptyParams);

        // Assert
        expect(result.isFailure, true);
        expect(result.failureOrNull, isA<ValidationFailure>());
        expect(result.failureOrNull?.message, contains('content'));
        
        // Repository should not be called for validation failures
        verifyNever(() => mockRepository.sendMessage(any()));
      });

      test('should return validation failure for whitespace-only content', () async {
        // Arrange
        final whitespaceParams = testParams.copyWith(content: '   \n  \t  ');

        // Act
        final result = await useCase.call(whitespaceParams);

        // Assert
        expect(result.isFailure, true);
        expect(result.failureOrNull, isA<ValidationFailure>());
        expect(result.failureOrNull?.message, contains('content'));
      });

      test('should return validation failure for empty senderId', () async {
        // Arrange
        final invalidParams = testParams.copyWith(senderId: '');

        // Act
        final result = await useCase.call(invalidParams);

        // Assert
        expect(result.isFailure, true);
        expect(result.failureOrNull, isA<ValidationFailure>());
        expect(result.failureOrNull?.message, contains('senderId'));
      });

      test('should return validation failure for empty roomId', () async {
        // Arrange
        final invalidParams = testParams.copyWith(roomId: '');

        // Act
        final result = await useCase.call(invalidParams);

        // Assert
        expect(result.isFailure, true);
        expect(result.failureOrNull, isA<ValidationFailure>());
        expect(result.failureOrNull?.message, contains('roomId'));
      });
    });

    group('Edge Cases', () {
      test('should handle very long message content', () async {
        // Arrange
        final longContent = 'A' * 10000; // 10k characters
        final longParams = testParams.copyWith(content: longContent);
        final longMessage = expectedMessage.copyWith(content: longContent);
        
        when(() => mockRepository.sendMessage(any()))
            .thenAnswer((_) async => Success(longMessage));

        // Act
        final result = await useCase.call(longParams);

        // Assert
        expect(result.isSuccess, true);
        expect(result.dataOrNull?.content.length, 10000);
      });

      test('should handle special characters and emojis', () async {
        // Arrange
        const specialContent = 'Hello 👋 World! 🌍 #hashtag @mention 中文';
        final specialParams = testParams.copyWith(content: specialContent);
        final specialMessage = expectedMessage.copyWith(content: specialContent);
        
        when(() => mockRepository.sendMessage(any()))
            .thenAnswer((_) async => Success(specialMessage));

        // Act
        final result = await useCase.call(specialParams);

        // Assert
        expect(result.isSuccess, true);
        expect(result.dataOrNull?.content, specialContent);
      });

      test('should handle network failure gracefully', () async {
        // Arrange
        const networkFailure = NetworkFailure(message: 'No internet connection');
        when(() => mockRepository.sendMessage(any()))
            .thenAnswer((_) async => const ResultFailure(networkFailure));

        // Act
        final result = await useCase.call(testParams);

        // Assert
        expect(result.isFailure, true);
        expect(result.failureOrNull, networkFailure);
      });
    });

    group('Parameters Validation', () {
      test('should pass valid parameters to repository', () async {
        // Arrange
        late Message capturedMessage;
        when(() => mockRepository.sendMessage(any()))
            .thenAnswer((invocation) async {
              capturedMessage = invocation.positionalArguments[0] as Message;
              return Success(capturedMessage);
            });

        // Act
        await useCase.call(testParams);

        // Assert
        expect(capturedMessage.senderId, testSenderId);
        expect(capturedMessage.roomId, testRoomId);
        expect(capturedMessage.content, testContent);
        expect(capturedMessage.messageType, MessageType.text);
        expect(capturedMessage.isRead, false); // Should default to false
        expect(capturedMessage.id, isNotEmpty); // Should have generated ID
        expect(capturedMessage.timestamp, isA<DateTime>()); // Should have timestamp
      });
    });
  });
}